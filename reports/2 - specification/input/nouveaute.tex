\section{Nouveauté}
	
	Les principales nouveauté trop cool de notre logiciels....	Aliquam finibus est ac cursus cursus. Fusce in libero ut nisi laoreet sodales. Cras vestibulum nec nulla in consequat. In eget lacus ut ipsum placerat ultrices. Nam diam magna, fermentum aliquam libero at, ornare eleifend diam. Sed et mi eget arcu bibendum congue. Vivamus in enim mollis, blandit sem in, hendrerit tellus.


	\subsection{Optimiseur}
		% Justifier utilité
		% Présentation fonctionnalité
		% Parler algo
		% Exemple
		
		Actuellement, une fois que l'expert a obtenu son arbre complet (qui peut se composer de plusieurs milliers de noeuds), il ne peut pas facilement identifier le chemin le moins couteux (selon un paramètre donné).
		Il s'agit en effet d'un travail manuel, relativement fastidieux, qui doit être recommencé à chaque modification de l'arbre.
		
		Pourtant, il s'agit d'une méthode systématique, qui peut être implémentée dans notre logiciel.
		Pouvoir identifier automatiquement le chemin optimal ferait ainsi gagner beaucoup de temps à l'expert.
		
		L'optimiseur prendrait donc en entrée:
		\begin{itemize}
			\item un arbre provenant du projet ;
			\item le paramètre à prendre en compte ;
			\item le critère ($min$ ou $max$).
		\end{itemize}
		
		Nous optiendrons en sortie un nouvel arbre (qui sera un sous ensemble de l'arbre d'entrée), contenant le chemin optimal. 
		L'utilisateur pourra ensuite le traiter comme un tout nouvel arbre, en fonction de son besoin.
		
		Nous allons maintenant détailler l'algorithme utilisé. Il s'agira d'une fontion récursive.

		\begin{lstlisting}
opti(racine, param, crit):
	l_fils = fils(racine)

	if vide(l_fils):
		return

	if mode(racine) == ou:
		v = param(l_fils[0])

		for n in l_fils[1:]:
			v = crit(v, param(n))

		for n in l_fils:
			if param(n) != v:
				delete(n) // will delete subtrees as well
	
	for n in fils(racine):
		opti(n, param, crit)
		\end{lstlisting}

		L'algorithme modifiera l'arbre en l'état (c'est pour cela que nous le ferons travailler sur une copie de l'arbre).
		\begin{itemize}
			\item \verb|racine| correspond au noeud à partir duquel nous élaguerons l'arbre.
			\item \verb|param| est une fonction renvoyant une valeur pour un noeud donné.
			\item \verb|crit| est une fonction prenant en paramètre deux valeurs et renvoie la valeur à \og garder \fg.
			\item \verb|fils| est une fonction renvoyant une liste de noeuds, correspondants aux fils du noeud passé en paramètre.
		\end{itemize}
		Ainsi, pour lancer l'optimisation, nous appelerons \verb|opti| avec la racine de l'arbre en paramètre.

		*Je vais chanter une petite chanson pour l'autostoppeur*

		Par exemple, prenons l'arbre .........
		Si on veut trouver le chemin optimal, avec en paramètre le coût, et en critère la fonction $min$, on obtiendra l'arbre de la figure \ref{fig:arbre_post_opti}.

		\begin{figure}
			\centering
			\includegraphics[width=0.5\textwidth]{figure/post_optimiseur.pdf}
			\caption{L'attaque idéale est ainsi facilement lisible.}
			\label{fig:arbre_post_opti}
		\end{figure}


	\subsection{Filtre}
		\begin{figure}
			\begin{center}
				\includegraphics[width=0.25\textwidth]{figure/filtre.png}
			\end{center}
			\caption{Filtre}
			\label{fig:filtre}
		\end{figure}

		A l'heure actuelle, l'analyse d'arbre de grandes tailles à l'aide d'ADTool est difficile. 
		En effet, ADTool a été pensé prioritairement pour la modélisation des systèmes sous forme d'ADTrees, et moins pour leurs analyses. 
		ADTool met à disposition de l'expert, comme cela a été précisé précédemment, un certain nombre d'outils pour l'assister dans la modélisation de son système, parmi lesquels se trouve la valuation des noeuds de l'arbre. 
		Une limite que présente ADTool est que, une fois le système à protéger complétement représenté sous la forme d'un ADTree, l'arbre peut être trop grand pour que l'expert puisse en retirer une information pertinante car le temps de parcours est trop long. 

		Dans un certain nombre de cas, l'expert va chercher à se défendre contre un attaquant précis. Dans ces cas, l'expert va chercher à identifier les ressources dont l'attaquant dispose (temps, argent, personnel humain, etc), ce qui peut amener l'expert à ne vouloir conserver que les chemins de l'arbre empruntables par 				l'attaquant. 

		En l'état, ADTool ne permet pas de faire cette sélection. Nous allons donc implémenter cette fonction dans notre logiciel, sous le nom de \textit{filtre}.

		Le filtre prendra plusieurs paramètres :
		\begin{itemize}
		\item L'abre à filtrer.
		\item Les paramètres étant des critères pour le filtrage.
		\item Les intervalles de sélection sur les paramètres.
		\end{itemize}

		Le filtre proposera deux types d'intervalles à l'expert pour chacun des paramètres : 
		L'intervalle global, qui devra être respecté par chacun des chemins conservés dans le sens où la valuation du chemin dans son ensemble rentre dans l'intervalle.
		L'intervalle unitaire, qui devra être respecté par chacun des noeuds des chemins retenus.

		Il est possible de combiner les intervalles et les paramètres entre eux 

		  %\item il est ainsi possible de combiner les critères de sélection (ex : entre 500 et 1000 euros au total et pas de dépenses de moins de 10 euros %et pas de plus de 100 euros ; et le temps entre X et Y et ….)
		 % \item barre de défilement pour les cas de surcharge de paramètres
		  %\item possibilité d'activer ou désactiver les paramètres ( bouton a cocher)
		  %\item bouton ``générer'' permet de créer un nouvelle arbre filtré en fonction des paramètres définie. Il est ouvert dans un nouvelle onglet de la %section ADTool de l'interface. 
		 % \item chaque arbre posséde son propre outil filtre. Lors de la génération, le nouvelle arbre posséde un outil filtre vide. 
		  %\item le nouvel arbre posséde un commentaire : filtre depuis l'arbre X avec paramétre Y, heure, version. \ldots
		  %\end{itemize}


\subsection{Paramètres de synthèse}

\subsubsection{Les paramètres de base d'ADTool}

ADTool dispose à l'heure actuelle de treize paramètres de base (appelés \textit{domains}), que nous allons présenter succinctement ci-dessous. Nous avons repris les noms (en anglais) qui apparaissent dans le logiciel. 
		
\begin{table*}[!h]
	\centering
	\begin{tabular}{|p{6cm}|p{5cm}|}
  \hline
  \textbf{Paramètre} & \textbf{Valeurs possibles} \\
  \hline
  Difficulty for the proponent (L,M,H) & 
 Low (bas), Medium (moyen), High (élevé) ou l'infini.
\\ \hline
Difficulty for the proponent (L,M,H,E) & 
Low (bas), Medium (moyen), High (élevé), Extreme (extrême) ou l'infini.
\\ \hline
Minimal cost for the proponent (not reusable) & 
Valeurs réelles positives, ou l'infini.\\ \hline
  Minimal skill level needed for the proponent
  & Valeurs entières positives, ou l'infini.\\ \hline
  Minimal time for the proponent (in parallel)
  & Valeurs réelles positives, ou l'infini.\\ \hline
  Minimal time for the proponent (sequential) (\textit{temps minimal séquentiel})
  & Valeurs réelles positives, ou l'infini.\\ \hline
  Overall maximal power consumption & 
  Valeurs réelles positives, ou l'infini.\\ \hline
  Probability of success &
  Valeurs réelles entre 0 et 1.\\ \hline
  Reachability of the proponent's goal in less than k units (in parallel)
  & Valeurs entières de 0 à k. \\ \hline
  Reachability of the proponent's goal in less than k units (sequential)
  & Valeurs entières de 0 à k. \\ \hline
  Satisfiability for the opponent
  & Vrai ou faux. \\ \hline
  Satisfiability for the proponent
  & Vrai ou faux. \\ \hline
  Satisfiability of the scenario
  & Vrai ou faux. \\
  \hline
\end{tabular}
	\caption{Description des paramètres}
	\label{tab:DescriptionParam}
\end{table*}

On voit dans le tableau que des termes particuliers sont utilisés pour désigner les deux parties de l'attaque : l'attaquant et le défenseur. En effet, ADTool permet de se mettre à la place de l'un ou de l'autre. Ainsi, le terme \textit{proponent} désigne l'attaquant (respectivement le défenseur) si on désire son point de vue. L'adversaire (\textit{opponent}) est alors le défenseur (respectivement l'attaquant). % un peu confus. je vois plus un truc du genre : les termes ooponnet et machine designent...

\subsubsection{L'éditeur de paramètres}

L'utilisateur est actuellement cantonné aux valuations présentées ci-dessus, et ne peut pas en créer d'autres sans passer par le code d'ADTool.Celui-ci étant libre de droits, c'est réalisable mais compliqué, surtout que l'utilisateur n'est pas forcément expérimenté en informatique. % Confus et inutile, juste préciser que l'utilisateur ne peut pas avoir de nouveau paramètres.
Nous souhaitons donc faciliter la création de nouveaux paramètres à partir de ceux déjà disponibles et des fonctions mathématiques de base (division, multiplication, min, max, etc). Ces nouvelles valuations pourront ensuite être appliquées aux arbres voulus, de la même manière que pour les paramètres de base. Elles pourront ainsi être utilisées pour analyser les arbres selon de nouveaux critères, et si besoin pour les élaguer à l'aide du filtre que nous allons implémenter.\\

Cette nouvelle fonctionnalité, appelée éditeur de paramètres, prendrait donc en entrée les éléments suivants :
\begin{itemize}[label=\ding{170},font=\color{magenta},parsep=0cm,itemsep=0cm, leftmargin=0cm]
\item un arbre provenant du projet ;
\item les paramètres intervenant dans la synthèse ;
\item les opérations mathématiques appliquées ;
\item le nom du paramètre de synthèse généré.
\end{itemize}

% exemples
		

